--- netcat-openbsd-1.228-1.orig/netcat.c	2025-01-05 08:43:46.000000000 +0800
+++ netcat-openbsd-1.228-1/netcat.c.new	2025-03-06 09:09:24.000000000 +0800
@@ -32,6 +32,9 @@
  * *Hobbit* <hobbit@avian.org>.
  */
 
+//#define DEBIAN_VERSION "1.228-1chen"
+#define _GNU_SOURCE
+
 #include <sys/types.h>
 #include <sys/socket.h>
 #include <sys/uio.h>
@@ -41,26 +44,78 @@
 #include <netinet/tcp.h>
 #include <netinet/ip.h>
 #include <arpa/telnet.h>
+#ifdef __linux__
+# include <linux/in6.h>
+#endif
+#if defined(TCP_MD5SIG_EXT) && defined(TCP_MD5SIG_MAXKEYLEN)
+# include <bsd/readpassphrase.h>
+#endif
+
+#ifndef IPTOS_LOWDELAY
+# define IPTOS_LOWDELAY 0x10
+# define IPTOS_THROUGHPUT 0x08
+# define IPTOS_RELIABILITY 0x04
+# define IPTOS_LOWCOST 0x02
+# define IPTOS_MINCOST IPTOS_LOWCOST
+#endif /* IPTOS_LOWDELAY */
+
+# ifndef IPTOS_DSCP_AF11
+# define	IPTOS_DSCP_AF11		0x28
+# define	IPTOS_DSCP_AF12		0x30
+# define	IPTOS_DSCP_AF13		0x38
+# define	IPTOS_DSCP_AF21		0x48
+# define	IPTOS_DSCP_AF22		0x50
+# define	IPTOS_DSCP_AF23		0x58
+# define	IPTOS_DSCP_AF31		0x68
+# define	IPTOS_DSCP_AF32		0x70
+# define	IPTOS_DSCP_AF33		0x78
+# define	IPTOS_DSCP_AF41		0x88
+# define	IPTOS_DSCP_AF42		0x90
+# define	IPTOS_DSCP_AF43		0x98
+# define	IPTOS_DSCP_EF		0xb8
+#endif /* IPTOS_DSCP_AF11 */
+
+#ifndef IPTOS_DSCP_CS0
+# define	IPTOS_DSCP_CS0		0x00
+# define	IPTOS_DSCP_CS1		0x20
+# define	IPTOS_DSCP_CS2		0x40
+# define	IPTOS_DSCP_CS3		0x60
+# define	IPTOS_DSCP_CS4		0x80
+# define	IPTOS_DSCP_CS5		0xa0
+# define	IPTOS_DSCP_CS6		0xc0
+# define	IPTOS_DSCP_CS7		0xe0
+#endif /* IPTOS_DSCP_CS0 */
+
+#ifndef IPTOS_DSCP_EF
+# define	IPTOS_DSCP_EF		0xb8
+#endif /* IPTOS_DSCP_EF */
+
 
 #include <ctype.h>
 #include <err.h>
 #include <errno.h>
+#include <fcntl.h>
 #include <limits.h>
 #include <netdb.h>
 #include <poll.h>
 #include <signal.h>
+#include <stddef.h>
 #include <stdarg.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include <time.h>
-#include <tls.h>
+#ifdef HAVE_TLS
+# include <tls.h>
+#endif
 #include <unistd.h>
+#include <bsd/stdlib.h>
+#include <bsd/string.h>
 
 #include "atomicio.h"
 
 #define PORT_MAX	65535
-#define UNIX_DG_TMP_SOCKET_SIZE	19
+#define UNIX_DG_TMP_SOCKET_SIZE	25
 
 #define POLL_STDIN	0
 #define POLL_NETOUT	1
@@ -68,12 +123,21 @@
 #define POLL_STDOUT	3
 #define BUFSIZE		16384
 
-#define TLS_NOVERIFY	(1 << 1)
-#define TLS_NONAME	(1 << 2)
-#define TLS_CCERT	(1 << 3)
-#define TLS_MUSTSTAPLE	(1 << 4)
+#ifdef HAVE_TLS
+# define TLS_NOVERIFY	(1 << 1)
+# define TLS_NONAME	(1 << 2)
+# define TLS_CCERT	(1 << 3)
+# define TLS_MUSTSTAPLE	(1 << 4)
+#endif
+
+#define CONNECTION_SUCCESS 0
+#define CONNECTION_FAILED 1
+#define CONNECTION_TIMEOUT 2
+
+#define UDP_SCAN_TIMEOUT 3			/* Seconds */
 
 /* Command Line Options */
+int	bflag;					/* Allow Broadcast */
 int	dflag;					/* detached, no stdin */
 int	Fflag;					/* fdpass sock to stdout */
 unsigned int iflag;				/* Interval Flag */
@@ -83,10 +147,12 @@
 int	nflag;					/* Don't do name look up */
 char   *Pflag;					/* Proxy username */
 char   *pflag;					/* Localport flag */
+int    qflag = -1;				/* Quit after some secs */
 int	rflag;					/* Random ports flag */
 char   *sflag;					/* Source Address */
 int	tflag;					/* Telnet Emulation */
 int	uflag;					/* UDP - Default to TCP */
+int	dccpflag;				/* DCCP - Default to TCP */
 int	vflag;					/* Verbosity */
 int	xflag;					/* Socks proxy */
 int	zflag;					/* Port Scan Flag */
@@ -97,6 +163,7 @@
 int	Tflag = -1;				/* IP Type of Service */
 int	rtableid = -1;
 
+#ifdef HAVE_TLS
 int	usetls;					/* use TLS */
 const char    *Cflag;				/* Public cert file */
 const char    *Kflag;				/* Private key file */
@@ -109,7 +176,13 @@
 char	*tls_ciphers;				/* TLS ciphers */
 char	*tls_protocols;				/* TLS protocols */
 FILE	*Zflag;					/* file to save peer cert */
-
+#else
+int	Cflag = 0;			/* CRLF line-ending */
+#endif
+
+#if defined(TCP_MD5SIG_EXT) && defined(TCP_MD5SIG_MAXKEYLEN)
+char Sflag_password[TCP_MD5SIG_MAXKEYLEN];
+#endif
 int recvcount, recvlimit;
 int timeout = -1;
 int family = AF_UNSPEC;
@@ -120,38 +193,58 @@
 
 void	atelnet(int, unsigned char *, unsigned int);
 int	strtoport(char *portstr, int udp);
-void	build_ports(char *);
+void	build_ports(char **);
 void	help(void) __attribute__((noreturn));
 int	local_listen(const char *, const char *, struct addrinfo);
+#ifdef HAVE_TLS
 void	readwrite(int, struct tls *);
+#else
+void	readwrite(int);
+#endif
 void	fdpass(int nfd) __attribute__((noreturn));
 int	remote_connect(const char *, const char *, struct addrinfo, char *);
+#ifdef HAVE_TLS
 int	timeout_tls(int, struct tls *, int (*)(struct tls *));
+#endif
 int	timeout_connect(int, const struct sockaddr *, socklen_t);
 int	socks_connect(const char *, const char *, struct addrinfo,
 	    const char *, const char *, struct addrinfo, int, const char *);
 int	udptest(int);
+int	unix_setup_sockaddr(char *, struct sockaddr_un *, int *);
 void	connection_info(const char *, const char *, const char *, const char *);
 int	unix_bind(char *, int);
 int	unix_connect(char *);
 int	unix_listen(char *);
-void	set_common_sockopts(int, int);
+void	set_common_sockopts(int, const struct sockaddr *);
 int	process_tos_opt(char *, int *);
+#ifdef HAVE_TLS
 int	process_tls_opt(char *, int *);
 void	save_peer_cert(struct tls *_tls_ctx, FILE *_fp);
+#endif
 void	report_sock(const char *, const struct sockaddr *, socklen_t, char *);
+#ifdef HAVE_TLS
 void	report_tls(struct tls *tls_ctx, char * host);
+#endif
 void	usage(int);
+#ifdef HAVE_TLS
 ssize_t drainbuf(int, unsigned char *, size_t *, struct tls *);
 ssize_t fillbuf(int, unsigned char *, size_t *, struct tls *);
 void	tls_setup_client(struct tls *, int, char *);
 struct tls *tls_setup_server(struct tls *, int, char *);
+#else
+ssize_t drainbuf(int, unsigned char *, size_t *, int);
+ssize_t fillbuf(int, unsigned char *, size_t *);
+#endif
+
+char *proto_name(int, int);
+static int connect_with_timeout(int, const struct sockaddr *, socklen_t, int);
+static void quit();
 
 int
 main(int argc, char *argv[])
 {
 	int ch, s = -1, ret, socksv;
-	char *host, *uport;
+	char *host, **uport;
 	char ipaddr[NI_MAXHOST];
 	struct addrinfo hints;
 	socklen_t len;
@@ -160,20 +253,28 @@
 	const char *errstr;
 	struct addrinfo proxyhints;
 	char unix_dg_tmp_socket_buf[UNIX_DG_TMP_SOCKET_SIZE];
+#ifdef HAVE_TLS
 	struct tls_config *tls_cfg = NULL;
 	struct tls *tls_ctx = NULL;
+#endif
 	uint32_t protocols;
 
 	ret = 1;
 	socksv = 5;
 	host = NULL;
 	uport = NULL;
+#ifdef HAVE_TLS
 	Rflag = tls_default_ca_cert_file();
+#endif
 
 	signal(SIGPIPE, SIG_IGN);
 
 	while ((ch = getopt(argc, argv,
-	    "46C:cDde:FH:hI:i:K:klM:m:NnO:o:P:p:R:rSs:T:tUuV:vW:w:X:x:Z:z"))
+#ifdef HAVE_TLS
+	    "46bC:cDde:FH:hI:i:K:klM:m:NnO:o:P:p:q:R:rSs:T:tUuV:vW:w:X:x:Z:z"))
+#else
+	    "46bCDdFhI:i:klM:m:NnO:P:p:q:rSs:T:tUuV:vW:w:X:x:Zz"))
+#endif
 	    != -1) {
 		switch (ch) {
 		case '4':
@@ -182,6 +283,13 @@
 		case '6':
 			family = AF_INET6;
 			break;
+		case 'b':
+#ifdef SO_BROADCAST
+			bflag = 1;
+#else
+			errx(1, "no broadcast frame support available");
+#endif
+			break;
 		case 'U':
 			family = AF_UNIX;
 			break;
@@ -195,24 +303,34 @@
 			else
 				errx(1, "unsupported proxy protocol");
 			break;
+#ifdef HAVE_TLS
 		case 'C':
 			Cflag = optarg;
 			break;
 		case 'c':
 			usetls = 1;
 			break;
+#else
+		case 'C':
+			Cflag = 1;
+			break;
+#endif
 		case 'd':
 			dflag = 1;
 			break;
+#ifdef HAVE_TLS
 		case 'e':
 			tls_expectname = optarg;
 			break;
+#endif
 		case 'F':
 			Fflag = 1;
 			break;
+#ifdef HAVE_TLS
 		case 'H':
 			tls_expecthash = optarg;
 			break;
+#endif
 		case 'h':
 			help();
 			break;
@@ -221,9 +339,11 @@
 			if (errstr)
 				errx(1, "interval %s: %s", errstr, optarg);
 			break;
+#ifdef HAVE_TLS
 		case 'K':
 			Kflag = optarg;
 			break;
+#endif
 		case 'k':
 			kflag = 1;
 			break;
@@ -252,10 +372,19 @@
 		case 'p':
 			pflag = optarg;
 			break;
+		case 'q':
+			qflag = strtonum(optarg, INT_MIN, INT_MAX, &errstr);
+			if (errstr)
+				errx(1, "quit timer %s: %s", errstr, optarg);
+			if (qflag >= 0)
+				Nflag = 1;
+			break;
+#ifdef HAVE_TLS
 		case 'R':
 			tls_cachanged = 1;
 			Rflag = optarg;
 			break;
+#endif
 		case 'r':
 			rflag = 1;
 			break;
@@ -268,11 +397,22 @@
 		case 'u':
 			uflag = 1;
 			break;
+		case 'Z':
+#if defined(IPPROTO_DCCP) && defined(SOCK_DCCP)
+			dccpflag = 1;
+#else
+			errx(1, "no DCCP support available");
+#endif
+			break;
 		case 'V':
+#ifdef RT_TABLEID_MAX
 			rtableid = (int)strtonum(optarg, 0,
 			    RT_TABLEID_MAX, &errstr);
 			if (errstr)
 				errx(1, "rtable %s: %s", errstr, optarg);
+#else
+			errx(1, "no alternate routing table support available");
+#endif
 			break;
 		case 'v':
 			vflag = 1;
@@ -293,12 +433,14 @@
 			if ((proxy = strdup(optarg)) == NULL)
 				err(1, NULL);
 			break;
+#ifdef HAVE_TLS
 		case 'Z':
 			if (strcmp(optarg, "-") == 0)
 				Zflag = stderr;
 			else if ((Zflag = fopen(optarg, "w")) == NULL)
 				err(1, "can't open %s", optarg);
 			break;
+#endif
 		case 'z':
 			zflag = 1;
 			break;
@@ -317,17 +459,28 @@
 				errx(1, "TCP send window %s: %s",
 				    errstr, optarg);
 			break;
+#ifdef HAVE_TLS
 		case 'o':
 			oflag = optarg;
 			break;
+#endif
 		case 'S':
+#if defined(TCP_MD5SIG_EXT) && defined(TCP_MD5SIG_MAXKEYLEN)
+			if (readpassphrase("TCP MD5SIG password: ",
+					Sflag_password, TCP_MD5SIG_MAXKEYLEN, RPP_REQUIRE_TTY) == NULL)
+				errx(1, "Unable to read TCP MD5SIG password");
 			Sflag = 1;
+#else
+			errx(1, "no TCP MD5 signature support available");
+#endif
 			break;
 		case 'T':
 			errstr = NULL;
 			errno = 0;
+#ifdef HAVE_TLS
 			if (process_tls_opt(optarg, &TLSopt))
 				break;
+#endif
 			if (process_tos_opt(optarg, &Tflag))
 				break;
 			if (strlen(optarg) > 1 && optarg[0] == '0' &&
@@ -337,7 +490,11 @@
 				Tflag = (int)strtonum(optarg, 0, 255,
 				    &errstr);
 			if (Tflag < 0 || Tflag > 255 || errstr || errno)
+#ifdef HAVE_TLS
 				errx(1, "illegal tos/tls value %s", optarg);
+#else
+				errx(1, "illegal tos value %s", optarg);
+#endif
 			break;
 		default:
 			usage(1);
@@ -346,21 +503,50 @@
 	argc -= optind;
 	argv += optind;
 
+#ifdef RT_TABLEID_MAX
 	if (rtableid >= 0)
 		if (setrtable(rtableid) == -1)
 			err(1, "setrtable");
+#endif
 
 	/* Cruft to make sure options are clean, and used properly. */
-	if (argc == 1 && family == AF_UNIX) {
-		host = argv[0];
-	} else if (argc == 1 && lflag) {
-		uport = argv[0];
-	} else if (argc == 2) {
+	if (argc == 0 && lflag) {
+		uport = &pflag;
+		host = sflag;
+	} else if (argc == 1 && !pflag &&
+			/* `nc -l 12345` or `nc -U bar` or `nc -uU -s foo bar` */
+			(!sflag || (family == AF_UNIX && uflag && !lflag))) {
+		if (family == AF_UNIX) {
+			host = argv[0];
+			uport = NULL;
+		} else if (lflag) {
+			host  = NULL;
+			uport = argv;
+		}
+	} else if (argc >= 2) {
+		if (lflag && (pflag || sflag || argc > 2))
+			usage(1); /* conflict */
 		host = argv[0];
-		uport = argv[1];
+		uport = &argv[1];
 	} else
 		usage(1);
 
+	if (family == AF_UNIX) {
+#if defined(IPPROTO_DCCP) && defined(SOCK_DCCP)
+		if (dccpflag)
+			errx(1, "cannot use -Z and -U");
+#endif
+		if (uport && *uport)
+			errx(1, "cannot use port with -U");
+		if (!host)
+			errx(1, "missing socket pathname");
+	} else if (!uport || !*uport)
+		errx(1, "missing port number");
+
+	if (lflag && zflag)
+		errx(1, "cannot use -z and -l");
+
+#ifdef HAVE_TLS
 	if (usetls) {
 		if (Cflag && unveil(Cflag, "r") == -1)
 			err(1, "unveil %s", Cflag);
@@ -395,42 +581,19 @@
 				err(1, "unveil /");
 		}
 	}
+#endif
 
-	if (family == AF_UNIX) {
-		if (pledge("stdio rpath wpath cpath tmppath unix", NULL) == -1)
-			err(1, "pledge");
-	} else if (Fflag && Pflag) {
-		if (pledge("stdio inet dns sendfd tty", NULL) == -1)
-			err(1, "pledge");
-	} else if (Fflag) {
-		if (pledge("stdio inet dns sendfd", NULL) == -1)
-			err(1, "pledge");
-	} else if (Pflag && usetls) {
-		if (pledge("stdio rpath inet dns tty", NULL) == -1)
-			err(1, "pledge");
-	} else if (Pflag) {
-		if (pledge("stdio inet dns tty", NULL) == -1)
-			err(1, "pledge");
-	} else if (usetls) {
-		if (pledge("stdio rpath inet dns", NULL) == -1)
-			err(1, "pledge");
-	} else if (pledge("stdio inet dns", NULL) == -1)
-		err(1, "pledge");
-
-	if (lflag && sflag)
-		errx(1, "cannot use -s and -l");
-	if (lflag && pflag)
-		errx(1, "cannot use -p and -l");
-	if (lflag && zflag)
-		errx(1, "cannot use -z and -l");
 	if (!lflag && kflag)
 		errx(1, "must use -l with -k");
+#ifdef HAVE_TLS
 	if (uflag && usetls)
 		errx(1, "cannot use -c and -u");
 	if ((family == AF_UNIX) && usetls)
 		errx(1, "cannot use -c and -U");
+#endif
 	if ((family == AF_UNIX) && Fflag)
 		errx(1, "cannot use -F and -U");
+#ifdef HAVE_TLS
 	if (Fflag && usetls)
 		errx(1, "cannot use -c and -F");
 	if (TLSopt && !usetls)
@@ -449,16 +612,27 @@
 		errx(1, "you must specify -c to use -H");
 	if (tls_expectname && !usetls)
 		errx(1, "you must specify -c to use -e");
+#endif
 
 	/* Get name of temporary socket for unix datagram client */
 	if ((family == AF_UNIX) && uflag && !lflag) {
 		if (sflag) {
 			unix_dg_tmp_socket = sflag;
 		} else {
-			strlcpy(unix_dg_tmp_socket_buf, "/tmp/nc.XXXXXXXXXX",
+			/* On Linux it's tempting to use abstract sockets here in
+			 * order to limit bookkeeping and avoid cluttering /tmp.
+			 * Unfortunately though this has security implications, as a
+			 * second client could inject server responses if they
+			 * manage to connect(2) to the temporary socket between the
+			 * first client's bind(2) and connect(2) calls.  OTOH for
+			 * pathname sockets the injection is only possible on Linux
+			 * when write access to the socket is granted. */
+			strlcpy(unix_dg_tmp_socket_buf, "/tmp/nc-XXXXXX",
+			    UNIX_DG_TMP_SOCKET_SIZE);
+			if (mkdtemp(unix_dg_tmp_socket_buf) == NULL)
+				err(1, "mkdtemp");
+			strlcat(unix_dg_tmp_socket_buf, "/recv.sock",
 			    UNIX_DG_TMP_SOCKET_SIZE);
-			if (mktemp(unix_dg_tmp_socket_buf) == NULL)
-				err(1, "mktemp");
 			unix_dg_tmp_socket = unix_dg_tmp_socket_buf;
 		}
 	}
@@ -467,8 +641,20 @@
 	if (family != AF_UNIX) {
 		memset(&hints, 0, sizeof(struct addrinfo));
 		hints.ai_family = family;
-		hints.ai_socktype = uflag ? SOCK_DGRAM : SOCK_STREAM;
-		hints.ai_protocol = uflag ? IPPROTO_UDP : IPPROTO_TCP;
+		if (uflag) {
+			hints.ai_socktype = SOCK_DGRAM;
+			hints.ai_protocol = IPPROTO_UDP;
+		}
+#if defined(IPPROTO_DCCP) && defined(SOCK_DCCP)
+		else if (dccpflag) {
+			hints.ai_socktype = SOCK_DCCP;
+			hints.ai_protocol = IPPROTO_DCCP;
+		}
+#endif
+		else {
+			hints.ai_socktype = SOCK_STREAM;
+			hints.ai_protocol = IPPROTO_TCP;
+		}
 		if (nflag)
 			hints.ai_flags |= AI_NUMERICHOST;
 	}
@@ -476,7 +662,10 @@
 	if (xflag) {
 		if (uflag)
 			errx(1, "no proxy support for UDP mode");
-
+#if defined(IPPROTO_DCCP) && defined(SOCK_DCCP)
+		if (dccpflag)
+			errx(1, "no proxy support for DCCP mode");
+#endif
 		if (lflag)
 			errx(1, "no proxy support for listen");
 
@@ -515,6 +704,7 @@
 			proxyhints.ai_flags |= AI_NUMERICHOST;
 	}
 
+#ifdef HAVE_TLS
 	if (usetls) {
 		if ((tls_cfg = tls_config_new()) == NULL)
 			errx(1, "unable to allocate TLS config");
@@ -551,6 +741,7 @@
 		} else if (pledge("stdio inet dns", NULL) == -1)
 			err(1, "pledge");
 	}
+#endif
 	if (lflag) {
 		ret = 0;
 
@@ -559,8 +750,12 @@
 				s = unix_bind(host, 0);
 			else
 				s = unix_listen(host);
-		}
+		} else
+			s = local_listen(host, *uport, hints);
+		if (s < 0)
+			err(1, NULL);
 
+#ifdef HAVE_TLS
 		if (usetls) {
 			tls_config_verify_client_optional(tls_cfg);
 			if ((tls_ctx = tls_server()) == NULL)
@@ -569,26 +764,20 @@
 				errx(1, "tls configuration failed (%s)",
 				    tls_error(tls_ctx));
 		}
+#endif
 		/* Allow only one connection at a time, but stay alive. */
 		for (;;) {
-			if (family != AF_UNIX) {
-				if (s != -1)
-					close(s);
-				s = local_listen(host, uport, hints);
-			}
-			if (s == -1)
-				err(1, NULL);
 			if (uflag && kflag) {
-				if (family == AF_UNIX) {
-					if (pledge("stdio unix", NULL) == -1)
-						err(1, "pledge");
-				}
 				/*
 				 * For UDP and -k, don't connect the socket,
 				 * let it receive datagrams from multiple
 				 * socket pairs.
 				 */
+#ifdef HAVE_TLS
 				readwrite(s, NULL);
+#else
+				readwrite(s);
+#endif
 			} else if (uflag && !kflag) {
 				/*
 				 * For UDP and not -k, we will use recvfrom()
@@ -609,18 +798,19 @@
 				if (rv == -1)
 					err(1, "connect");
 
-				if (family == AF_UNIX) {
-					if (pledge("stdio unix", NULL) == -1)
-						err(1, "pledge");
-				}
 				if (vflag)
 					report_sock("Connection received",
 					    (struct sockaddr *)&z, len,
 					    family == AF_UNIX ? host : NULL);
 
+#ifdef HAVE_TLS
 				readwrite(s, NULL);
 			} else {
 				struct tls *tls_cctx = NULL;
+#else
+				readwrite(s);
+			} else {
+#endif
 				int connfd;
 
 				len = sizeof(cliaddr);
@@ -634,6 +824,7 @@
 					report_sock("Connection received",
 					    (struct sockaddr *)&cliaddr, len,
 					    family == AF_UNIX ? host : NULL);
+#ifdef HAVE_TLS
 				if ((usetls) &&
 				    (tls_cctx = tls_setup_server(tls_ctx, connfd, host)))
 					readwrite(connfd, tls_cctx);
@@ -643,25 +834,42 @@
 					timeout_tls(s, tls_cctx, tls_close);
 				close(connfd);
 				tls_free(tls_cctx);
+#else
+				readwrite(connfd);
+				close(connfd);
+#endif
 			}
 
-			if (!kflag)
+			if (!kflag) {
+				if (s != -1)
+					close(s);
 				break;
+			}
 		}
 	} else if (family == AF_UNIX) {
 		ret = 0;
 
 		if ((s = unix_connect(host)) > 0) {
 			if (!zflag)
+#ifdef HAVE_TLS
 				readwrite(s, NULL);
+#else
+				readwrite(s);
+#endif
 			close(s);
 		} else {
 			warn("%s", host);
 			ret = 1;
 		}
 
-		if (uflag)
+		if (uflag && !sflag) {
 			unlink(unix_dg_tmp_socket);
+			char *nam = strrchr(unix_dg_tmp_socket, '/');
+			if (nam != NULL) {
+				nam[0] = '\0';
+				rmdir(unix_dg_tmp_socket);
+			}
+		}
 		return ret;
 	} else {
 		int i = 0;
@@ -673,6 +881,7 @@
 		for (s = -1, i = 0; portlist[i] != NULL; i++) {
 			if (s != -1)
 				close(s);
+#ifdef HAVE_TLS
 			tls_free(tls_ctx);
 			tls_ctx = NULL;
 
@@ -683,6 +892,7 @@
 					errx(1, "tls configuration failed (%s)",
 					    tls_error(tls_ctx));
 			}
+#endif
 			if (xflag)
 				s = socks_connect(host, portlist[i], hints,
 				    proxy, proxyport, proxyhints, socksv,
@@ -706,12 +916,15 @@
 						continue;
 					}
 				}
-				if (print_info == 1)
+				if (print_info == 1) {
+					char *proto = proto_name(uflag, dccpflag);
 					connection_info(host, portlist[i],
-					    uflag ? "udp" : "tcp", ipaddr);
+					    proto, ipaddr);
+				}
 			}
 			if (Fflag)
 				fdpass(s);
+#ifdef HAVE_TLS
 			else {
 				if (usetls)
 					tls_setup_client(tls_ctx, s, host);
@@ -720,17 +933,63 @@
 				if (tls_ctx)
 					timeout_tls(s, tls_ctx, tls_close);
 			}
+#else
+			else if (!zflag)
+				readwrite(s);
+#endif
 		}
 	}
 
 	if (s != -1)
 		close(s);
+#ifdef HAVE_TLS
 	tls_free(tls_ctx);
 	tls_config_free(tls_cfg);
+#endif
 
 	return ret;
 }
 
+int
+unix_setup_sockaddr(char *path, struct sockaddr_un *s_un, int *addrlen)
+{
+	int sun_path_len;
+
+	*addrlen = offsetof(struct sockaddr_un, sun_path);
+	memset(s_un, 0, *addrlen);
+	s_un->sun_family = AF_UNIX;
+
+	if (path[0] == '\0') {
+		/* Always reject the empty path, aka NUL abstract socket on
+		 * Linux (OTOH the *empty* abstract socket is supported and
+		 * specified as @""). */
+		errno = EINVAL;
+		return -1;
+	}
+#ifdef __linux__
+	/* If the unix domain socket path starts with '@',
+	 * treat it as a Linux abstract name. */
+	else if (path[0] == '@') {
+		if ((sun_path_len = strlen(path)) <= sizeof(s_un->sun_path)) {
+			s_un->sun_path[0] = '\0';
+			strncpy(s_un->sun_path+1, path+1, sun_path_len-1);
+			*addrlen += sun_path_len;
+		} else {
+			errno = ENAMETOOLONG;
+			return -1;
+		}
+	}
+#endif
+	else if ((sun_path_len = strlcpy(s_un->sun_path, path, sizeof(s_un->sun_path))) <
+	    sizeof(s_un->sun_path))
+		*addrlen += sun_path_len + 1; /* account for trailing '\0' */
+	else {
+		errno = ENAMETOOLONG;
+		return -1;
+	}
+	return 0;
+}
+
 /*
  * unix_bind()
  * Returns a unix socket bound to the given path
@@ -739,24 +998,22 @@
 unix_bind(char *path, int flags)
 {
 	struct sockaddr_un s_un;
-	int s, save_errno;
+	int s, save_errno, addrlen;
+
+	if (unix_setup_sockaddr(path, &s_un, &addrlen) == -1)
+		return -1;
 
 	/* Create unix domain socket. */
 	if ((s = socket(AF_UNIX, flags | (uflag ? SOCK_DGRAM : SOCK_STREAM),
 	    0)) == -1)
 		return -1;
 
-	memset(&s_un, 0, sizeof(struct sockaddr_un));
-	s_un.sun_family = AF_UNIX;
-
-	if (strlcpy(s_un.sun_path, path, sizeof(s_un.sun_path)) >=
-	    sizeof(s_un.sun_path)) {
-		close(s);
-		errno = ENAMETOOLONG;
-		return -1;
-	}
+#ifdef __linux__
+	if (path[0] != '@')
+#endif
+	unlink(path);
 
-	if (bind(s, (struct sockaddr *)&s_un, sizeof(s_un)) == -1) {
+	if (bind(s, (struct sockaddr *)&s_un, addrlen) == -1) {
 		save_errno = errno;
 		close(s);
 		errno = save_errno;
@@ -768,6 +1025,7 @@
 	return s;
 }
 
+#ifdef HAVE_TLS
 int
 timeout_tls(int s, struct tls *tls_ctx, int (*func)(struct tls *))
 {
@@ -855,6 +1113,7 @@
 	}
 	return NULL;
 }
+#endif
 
 /*
  * unix_connect()
@@ -864,26 +1123,20 @@
 unix_connect(char *path)
 {
 	struct sockaddr_un s_un;
-	int s, save_errno;
+	int s, save_errno, addrlen;
+
+	if (unix_setup_sockaddr(path, &s_un, &addrlen) == -1)
+		return -1;
 
 	if (uflag) {
 		if ((s = unix_bind(unix_dg_tmp_socket, SOCK_CLOEXEC)) == -1)
-			return -1;
+			err(1, "%s", unix_dg_tmp_socket);
 	} else {
 		if ((s = socket(AF_UNIX, SOCK_STREAM | SOCK_CLOEXEC, 0)) == -1)
 			return -1;
 	}
 
-	memset(&s_un, 0, sizeof(struct sockaddr_un));
-	s_un.sun_family = AF_UNIX;
-
-	if (strlcpy(s_un.sun_path, path, sizeof(s_un.sun_path)) >=
-	    sizeof(s_un.sun_path)) {
-		close(s);
-		errno = ENAMETOOLONG;
-		return -1;
-	}
-	if (connect(s, (struct sockaddr *)&s_un, sizeof(s_un)) == -1) {
+	if (connect(s, (struct sockaddr *)&s_un, addrlen) == -1) {
 		save_errno = errno;
 		close(s);
 		errno = save_errno;
@@ -913,6 +1166,21 @@
 	return s;
 }
 
+char *proto_name(int uflag, int dccpflag) {
+	char *proto = NULL;
+
+	if (uflag)
+		proto = "udp";
+#if defined(IPPROTO_DCCP) && defined(SOCK_DCCP)
+	else if (dccpflag)
+		proto = "dccp";
+#endif
+	else
+		proto = "tcp";
+
+	return proto;
+}
+
 /*
  * remote_connect()
  * Returns a socket connected to a remote host. Properly binds to a local
@@ -938,12 +1206,26 @@
 		if (sflag || pflag) {
 			struct addrinfo ahints, *ares;
 
+#ifdef SO_BINDANY
 			/* try SO_BINDANY, but don't insist */
 			setsockopt(s, SOL_SOCKET, SO_BINDANY, &on, sizeof(on));
+#endif
 			memset(&ahints, 0, sizeof(struct addrinfo));
 			ahints.ai_family = res->ai_family;
-			ahints.ai_socktype = uflag ? SOCK_DGRAM : SOCK_STREAM;
-			ahints.ai_protocol = uflag ? IPPROTO_UDP : IPPROTO_TCP;
+			if (uflag) {
+				ahints.ai_socktype = SOCK_DGRAM;
+				ahints.ai_protocol = IPPROTO_UDP;
+			}
+#if defined(IPPROTO_DCCP) && defined(SOCK_DCCP)
+			else if (dccpflag) {
+				hints.ai_socktype = SOCK_DCCP;
+				hints.ai_protocol = IPPROTO_DCCP;
+			}
+#endif
+			else {
+				ahints.ai_socktype = SOCK_STREAM;
+				ahints.ai_protocol = IPPROTO_TCP;
+			}
 			ahints.ai_flags = AI_PASSIVE;
 			if ((error = getaddrinfo(sflag, pflag, &ahints, &ares)))
 				errx(1, "getaddrinfo: %s", gai_strerror(error));
@@ -954,7 +1236,7 @@
 			freeaddrinfo(ares);
 		}
 
-		set_common_sockopts(s, res->ai_family);
+		set_common_sockopts(s, res->ai_addr);
 
 		if (ipaddr != NULL) {
 			herr = getnameinfo(res->ai_addr, res->ai_addrlen,
@@ -969,18 +1251,23 @@
 			}
 		}
 
-		if (timeout_connect(s, res->ai_addr, res->ai_addrlen) == 0)
+		if ((error = connect_with_timeout(s, res->ai_addr, res->ai_addrlen,
+		    timeout)) == CONNECTION_SUCCESS)
 			break;
 
+		char *proto = proto_name(uflag, dccpflag);
+
 		if (vflag) {
 			/* only print IP if there is something to report */
 			if (nflag || ipaddr == NULL ||
 			    (strncmp(host, ipaddr, NI_MAXHOST) == 0))
-				warn("connect to %s port %s (%s) failed", host,
-				    port, uflag ? "udp" : "tcp");
+				warn("connect to %s port %s (%s) %s", host,
+				    port, proto,
+				    error == CONNECTION_TIMEOUT ? "timed out" : "failed");
 			else
-				warn("connect to %s (%s) port %s (%s) failed",
-				    host, ipaddr, port, uflag ? "udp" : "tcp");
+				warn("connect to %s (%s) port %s (%s) %s",
+				    host, ipaddr, port, proto,
+				    error == CONNECTION_TIMEOUT ? "timed out" : "failed");
 		}
 
 		save_errno = errno;
@@ -1022,6 +1309,68 @@
 	return ret;
 }
 
+static int connect_with_timeout(int fd, const struct sockaddr *sa,
+    socklen_t salen, int ctimeout)
+{
+	int err;
+	struct timeval tv, *tvp = NULL;
+	fd_set connect_fdset;
+	socklen_t len;
+	int orig_flags;
+
+	orig_flags = fcntl(fd, F_GETFL, 0);
+	if (fcntl(fd, F_SETFL, orig_flags | O_NONBLOCK) < 0 ) {
+		warn("can't set O_NONBLOCK - timeout not available");
+		if (connect(fd, sa, salen) == 0)
+			return CONNECTION_SUCCESS;
+		else
+			return CONNECTION_FAILED;
+	}
+
+	/* set connect timeout */
+	if (ctimeout > 0) {
+		tv.tv_sec = (time_t)ctimeout/1000;
+		tv.tv_usec = 0;
+		tvp = &tv;
+	}
+
+	/* attempt the connection */
+	err = connect(fd, sa, salen);
+	if (err != 0 && errno == EINPROGRESS) {
+		/* connection is proceeding
+		 * it is complete (or failed) when select returns */
+
+		/* initialize connect_fdset */
+		FD_ZERO(&connect_fdset);
+		FD_SET(fd, &connect_fdset);
+
+		/* call select */
+		do {
+			err = select(fd + 1, NULL, &connect_fdset, NULL, tvp);
+		} while (err < 0 && errno == EINTR);
+
+		/* select error */
+		if (err < 0)
+			errx(1,"select error: %s", strerror(errno));
+		/* we have reached a timeout */
+		if (err == 0)
+			return CONNECTION_TIMEOUT;
+		/* select returned successfully, but we must test socket
+		 * error for result */
+		len = sizeof(err);
+		if (getsockopt(fd, SOL_SOCKET, SO_ERROR, &err, &len) < 0)
+			errx(1, "getsockopt error: %s", strerror(errno));
+		/* setup errno according to the result returned by
+		 * getsockopt */
+		if (err != 0)
+			errno = err;
+	}
+
+	/* return aborted if an error occured, and valid otherwise */
+	fcntl(fd, F_SETFL, orig_flags);
+	return (err != 0)? CONNECTION_FAILED : CONNECTION_SUCCESS;
+}
+
 /*
  * local_listen()
  * Returns a socket listening on a local port, binds to specified source
@@ -1052,11 +1401,17 @@
 		    res->ai_protocol)) == -1)
 			continue;
 
+		ret = setsockopt(s, SOL_SOCKET, SO_REUSEADDR, &x, sizeof(x));
+		if (ret == -1)
+			warn("Couldn't set SO_REUSEADDR");
+
+#ifdef SO_REUSEPORT
 		ret = setsockopt(s, SOL_SOCKET, SO_REUSEPORT, &x, sizeof(x));
 		if (ret == -1)
-			err(1, NULL);
+			warn("Couldn't set SO_REUSEPORT");
+#endif
 
-		set_common_sockopts(s, res->ai_family);
+		set_common_sockopts(s, res->ai_addr);
 
 		if (bind(s, (struct sockaddr *)res->ai_addr,
 		    res->ai_addrlen) == 0)
@@ -1093,7 +1448,11 @@
  * Loop that polls on the network file descriptor and stdin.
  */
 void
+#ifdef HAVE_TLS
 readwrite(int net_fd, struct tls *tls_ctx)
+#else
+readwrite(int net_fd)
+#endif
 {
 	struct pollfd pfd[4];
 	int stdin_fd = STDIN_FILENO;
@@ -1128,21 +1487,27 @@
 	while (1) {
 		/* both inputs are gone, buffers are empty, we are done */
 		if (pfd[POLL_STDIN].fd == -1 && pfd[POLL_NETIN].fd == -1 &&
-		    stdinbufpos == 0 && netinbufpos == 0)
-			return;
+		    stdinbufpos == 0 && netinbufpos == 0) {
+			if (qflag <= 0)
+				return;
+			goto delay_exit;
+		}
 		/* both outputs are gone, we can't continue */
-		if (pfd[POLL_NETOUT].fd == -1 && pfd[POLL_STDOUT].fd == -1)
-			return;
+		if (pfd[POLL_NETOUT].fd == -1 && pfd[POLL_STDOUT].fd == -1) {
+			if (qflag <= 0)
+				return;
+			goto delay_exit;
+		}
 		/* listen and net in gone, queues empty, done */
 		if (lflag && pfd[POLL_NETIN].fd == -1 &&
-		    stdinbufpos == 0 && netinbufpos == 0)
-			return;
-
-		/* help says -i is for "wait between lines sent". We read and
-		 * write arbitrary amounts of data, and we don't want to start
-		 * scanning for newlines, so this is as good as it gets */
-		if (iflag)
-			sleep(iflag);
+		    stdinbufpos == 0 && netinbufpos == 0) {
+			if (qflag <= 0)
+				return;
+delay_exit:
+			close(net_fd);
+			signal(SIGALRM, quit);
+			alarm(qflag);
+		}
 
 		/* poll */
 		num_fds = poll(pfd, 4, timeout);
@@ -1193,12 +1558,17 @@
 		/* try to read from stdin */
 		if (pfd[POLL_STDIN].revents & POLLIN && stdinbufpos < BUFSIZE) {
 			ret = fillbuf(pfd[POLL_STDIN].fd, stdinbuf,
+#ifdef HAVE_TLS
 			    &stdinbufpos, NULL);
 			if (ret == TLS_WANT_POLLIN)
 				pfd[POLL_STDIN].events = POLLIN;
 			else if (ret == TLS_WANT_POLLOUT)
 				pfd[POLL_STDIN].events = POLLOUT;
-			else if (ret == 0 || ret == -1)
+			else
+#else
+			    &stdinbufpos);
+#endif
+			if (ret == 0 || ret == -1)
 				pfd[POLL_STDIN].fd = -1;
 			/* read something - poll net out */
 			if (stdinbufpos > 0)
@@ -1210,12 +1580,17 @@
 		/* try to write to network */
 		if (pfd[POLL_NETOUT].revents & POLLOUT && stdinbufpos > 0) {
 			ret = drainbuf(pfd[POLL_NETOUT].fd, stdinbuf,
+#ifdef HAVE_TLS
 			    &stdinbufpos, tls_ctx);
 			if (ret == TLS_WANT_POLLIN)
 				pfd[POLL_NETOUT].events = POLLIN;
 			else if (ret == TLS_WANT_POLLOUT)
 				pfd[POLL_NETOUT].events = POLLOUT;
-			else if (ret == -1)
+			else
+#else
+			    &stdinbufpos, (iflag || Cflag) ? 1 : 0);
+#endif
+			if (ret == -1)
 				pfd[POLL_NETOUT].fd = -1;
 			/* buffer empty - remove self from polling */
 			if (stdinbufpos == 0)
@@ -1227,12 +1602,17 @@
 		/* try to read from network */
 		if (pfd[POLL_NETIN].revents & POLLIN && netinbufpos < BUFSIZE) {
 			ret = fillbuf(pfd[POLL_NETIN].fd, netinbuf,
+#ifdef HAVE_TLS
 			    &netinbufpos, tls_ctx);
 			if (ret == TLS_WANT_POLLIN)
 				pfd[POLL_NETIN].events = POLLIN;
 			else if (ret == TLS_WANT_POLLOUT)
 				pfd[POLL_NETIN].events = POLLOUT;
-			else if (ret == -1)
+			else
+#else
+			    &netinbufpos);
+#endif
+			if (ret == -1)
 				pfd[POLL_NETIN].fd = -1;
 			/* eof on net in - remove from pfd */
 			if (ret == 0) {
@@ -1259,12 +1639,17 @@
 		/* try to write to stdout */
 		if (pfd[POLL_STDOUT].revents & POLLOUT && netinbufpos > 0) {
 			ret = drainbuf(pfd[POLL_STDOUT].fd, netinbuf,
+#ifdef HAVE_TLS
 			    &netinbufpos, NULL);
 			if (ret == TLS_WANT_POLLIN)
 				pfd[POLL_STDOUT].events = POLLIN;
 			else if (ret == TLS_WANT_POLLOUT)
 				pfd[POLL_STDOUT].events = POLLOUT;
-			else if (ret == -1)
+			else
+#else
+			    &netinbufpos, 0);
+#endif
+			if (ret == -1)
 				pfd[POLL_STDOUT].fd = -1;
 			/* buffer empty - remove self from polling */
 			if (netinbufpos == 0)
@@ -1279,6 +1664,13 @@
 			if (pfd[POLL_NETOUT].fd != -1 && Nflag)
 				shutdown(pfd[POLL_NETOUT].fd, SHUT_WR);
 			pfd[POLL_NETOUT].fd = -1;
+			/* #817050: handle UDP sockets and kflag */
+			if ((lflag || uflag) && pfd[POLL_NETIN].fd != -1 &&
+			    qflag >= 0 && netinbufpos == 0) {
+				shutdown(pfd[POLL_NETIN].fd, SHUT_RD);
+				pfd[POLL_NETIN].fd = -1;
+				kflag = 0;
+			}
 		}
 		/* net in gone and queue empty? */
 		if (pfd[POLL_NETIN].fd == -1 && netinbufpos == 0) {
@@ -1288,26 +1680,43 @@
 }
 
 ssize_t
-drainbuf(int fd, unsigned char *buf, size_t *bufpos, struct tls *tls)
+drainbuf(int fd, unsigned char *buf, size_t *bufpos, int oneline)
 {
-	ssize_t n;
+	ssize_t n, r;
 	ssize_t adjust;
+	unsigned char *lf = NULL;
 
 	if (fd == -1)
 		return -1;
 
-	if (tls) {
-		n = tls_write(tls, buf, *bufpos);
-		if (n == -1)
-			errx(1, "tls write failed (%s)", tls_error(tls));
-	} else {
-		n = write(fd, buf, *bufpos);
-		/* don't treat EAGAIN, EINTR as error */
-		if (n == -1 && (errno == EAGAIN || errno == EINTR))
-			n = TLS_WANT_POLLOUT;
-	}
+	if (oneline)
+		lf = memchr(buf, '\n', *bufpos);
+	if (lf == NULL) {
+		n = *bufpos;
+		oneline = 0;
+	}
+	else if (Cflag && (lf == buf || buf[lf - buf - 1] != '\r')) {
+		n = lf - buf;
+		oneline = 2;
+	}
+	else
+		n = lf - buf + 1;
+	if (n > 0)
+		n = write(fd, buf, n);
+
+	/* don't treat EAGAIN, EINTR as error */
+	if (n == -1 && (errno == EAGAIN || errno == EINTR))
+		n = -2;
+	if (oneline == 2 && n >= 0)
+		n++;
 	if (n <= 0)
 		return n;
+
+	if (oneline == 2 && (r = atomicio(vwrite, fd, "\r\n", 2)) != 2)
+		err(1, "write failed (%zu/2)", r);
+	if (oneline > 0 && iflag)
+		sleep(iflag);
+
 	/* adjust buffer */
 	adjust = *bufpos - n;
 	if (adjust > 0)
@@ -1317,7 +1726,11 @@
 }
 
 ssize_t
+#ifdef HAVE_TLS
 fillbuf(int fd, unsigned char *buf, size_t *bufpos, struct tls *tls)
+#else
+fillbuf(int fd, unsigned char *buf, size_t *bufpos)
+#endif
 {
 	size_t num = BUFSIZE - *bufpos;
 	ssize_t n;
@@ -1325,16 +1738,22 @@
 	if (fd == -1)
 		return -1;
 
+#ifdef HAVE_TLS
 	if (tls) {
 		n = tls_read(tls, buf + *bufpos, num);
 		if (n == -1)
 			errx(1, "tls read failed (%s)", tls_error(tls));
 	} else {
+#endif
 		n = read(fd, buf + *bufpos, num);
 		/* don't treat EAGAIN, EINTR as error */
 		if (n == -1 && (errno == EAGAIN || errno == EINTR))
+#ifdef HAVE_TLS
 			n = TLS_WANT_POLLIN;
 	}
+#else
+			n = -2;
+#endif
 	if (n <= 0)
 		return n;
 	*bufpos += n;
@@ -1457,51 +1876,61 @@
  * that we should try to connect to.
  */
 void
-build_ports(char *p)
+build_ports(char **p)
 {
+	struct servent *sv;
 	char *n;
 	int hi, lo, cp;
 	int x = 0;
+	int i;
 
-	if (isdigit((unsigned char)*p) && (n = strchr(p, '-')) != NULL) {
-		*n = '\0';
-		n++;
-
-		/* Make sure the ports are in order: lowest->highest. */
-		hi = strtoport(n, uflag);
-		lo = strtoport(p, uflag);
-		if (lo > hi) {
-			cp = hi;
-			hi = lo;
-			lo = cp;
-		}
-
-		/*
-		 * Initialize portlist with a random permutation.  Based on
-		 * Knuth, as in ip_randomid() in sys/netinet/ip_id.c.
-		 */
-		if (rflag) {
-			for (x = 0; x <= hi - lo; x++) {
-				cp = arc4random_uniform(x + 1);
-				portlist[x] = portlist[cp];
-				if (asprintf(&portlist[cp], "%d", x + lo) == -1)
-					err(1, "asprintf");
+	char *proto = proto_name(uflag, dccpflag);
+	for (i = 0; p[i] != NULL; i++) {
+		sv = getservbyname(p[i], proto);
+		if (sv) {
+			if (asprintf(&portlist[x], "%d", ntohs(sv->s_port)) < 0)
+				err(1, "asprintf");
+			x++;
+		} else if (isdigit((unsigned char)*p[i]) && (n = strchr(p[i], '-')) != NULL) {
+			*n = '\0';
+			n++;
+
+			/* Make sure the ports are in order: lowest->highest. */
+			hi = strtoport(n, uflag);
+			lo = strtoport(p[i], uflag);
+			if (lo > hi) {
+				cp = hi;
+				hi = lo;
+				lo = cp;
 			}
-		} else { /* Load ports sequentially. */
+
+			/* Load ports sequentially. */
 			for (cp = lo; cp <= hi; cp++) {
 				if (asprintf(&portlist[x], "%d", cp) == -1)
 					err(1, "asprintf");
 				x++;
 			}
+		} else {
+			hi = strtoport(p[i], uflag);
+			if (asprintf(&portlist[x], "%d", hi) < 0)
+				err(1, "asprintf");
+			x++;
 		}
-	} else {
-		char *tmp;
+	}
 
-		hi = strtoport(p, uflag);
-		if (asprintf(&tmp, "%d", hi) != -1)
-			portlist[0] = tmp;
-		else
-			err(1, NULL);
+	/*
+	 * Initialize portlist with a random permutation using
+	 * Fisher–Yates shuffle.
+	 */
+	if (rflag) {
+		for (i = x-1; i > 0; i--) {
+			cp = arc4random_uniform(i+1);
+			if (cp != i) {
+				n = portlist[i];
+				portlist[i] = portlist[cp];
+				portlist[cp] = n;
+			}
+		}
 	}
 }
 
@@ -1513,19 +1942,24 @@
 int
 udptest(int s)
 {
-	int i, ret;
+	int i, t;
 
 	/* Only write to the socket in scan mode or interactive mode. */
 	if (!zflag && !isatty(STDIN_FILENO))
 		return 0;
 
-	for (i = 0; i <= 3; i++) {
-		if (write(s, "X", 1) == 1)
-			ret = 1;
-		else
-			ret = -1;
+	if ((write(s, "X", 1) != 1) ||
+	    ((write(s, "X", 1) != 1) && (errno == ECONNREFUSED)))
+		return -1;
+
+	/* Give the remote host some time to reply. */
+	for (i = 0, t = (timeout == -1) ? UDP_SCAN_TIMEOUT : (timeout / 1000);
+	     i < t; i++) {
+		sleep(1);
+		if ((write(s, "X", 1) != 1) && (errno == ECONNREFUSED))
+			return -1;
 	}
-	return ret;
+	return 1;
 }
 
 void
@@ -1555,15 +1989,35 @@
 }
 
 void
-set_common_sockopts(int s, int af)
+set_common_sockopts(int s, const struct sockaddr* sa)
 {
 	int x = 1;
+	int af = sa->sa_family;
 
+#ifdef SO_BROADCAST
+	if (bflag) {
+		/* allow datagram sockets to send packets to a broadcast address
+		 * (this option has no effect on stream-oriented sockets) */
+		if (setsockopt(s, SOL_SOCKET, SO_BROADCAST,
+			&x, sizeof(x)) == -1)
+			err(1, NULL);
+	}
+#endif
+#if defined(TCP_MD5SIG_EXT) && defined(TCP_MD5SIG_MAXKEYLEN)
 	if (Sflag) {
-		if (setsockopt(s, IPPROTO_TCP, TCP_MD5SIG,
-		    &x, sizeof(x)) == -1)
+		struct tcp_md5sig sig;
+		memset(&sig, 0, sizeof(sig));
+		memcpy(&sig.tcpm_addr, sa, sizeof(struct sockaddr_storage));
+		sig.tcpm_keylen = TCP_MD5SIG_MAXKEYLEN < strlen(Sflag_password)
+		    ? TCP_MD5SIG_MAXKEYLEN
+		    : strlen(Sflag_password);
+		memcpy(sig.tcpm_key, Sflag_password, sig.tcpm_keylen);
+		sig.tcpm_flags = TCP_MD5SIG_FLAG_PREFIX;
+		if (setsockopt(s, IPPROTO_TCP, TCP_MD5SIG_EXT,
+		    &sig, sizeof(sig)) == -1)
 			err(1, NULL);
 	}
+#endif
 	if (Dflag) {
 		if (setsockopt(s, SOL_SOCKET, SO_DEBUG,
 		    &x, sizeof(x)) == -1)
@@ -1574,9 +2028,14 @@
 		    IP_TOS, &Tflag, sizeof(Tflag)) == -1)
 			err(1, "set IP ToS");
 
+#ifdef IPV6_TCLASS
 		else if (af == AF_INET6 && setsockopt(s, IPPROTO_IPV6,
 		    IPV6_TCLASS, &Tflag, sizeof(Tflag)) == -1)
 			err(1, "set IPv6 traffic class");
+#else
+		else if (af == AF_INET6)
+			errx(1, "can't set IPv6 traffic class (unavailable)");
+#endif
 	}
 	if (Iflag) {
 		if (setsockopt(s, SOL_SOCKET, SO_RCVBUF,
@@ -1594,19 +2053,34 @@
 		    IP_TTL, &ttl, sizeof(ttl)))
 			err(1, "set IP TTL");
 
+#ifdef IPV6_UNICAST_HOPS
 		else if (af == AF_INET6 && setsockopt(s, IPPROTO_IPV6,
 		    IPV6_UNICAST_HOPS, &ttl, sizeof(ttl)))
 			err(1, "set IPv6 unicast hops");
+#else
+		else if (af == AF_INET6)
+			errx(1, "can't set IPv6 unicast hops (unavailable)");
+#endif
 	}
 
 	if (minttl != -1) {
+#ifdef IP_MINTTL
 		if (af == AF_INET && setsockopt(s, IPPROTO_IP,
 		    IP_MINTTL, &minttl, sizeof(minttl)))
 			err(1, "set IP min TTL");
+#else
+		if (af == AF_INET)
+			errx(1, "can't set IP min TTL (unavailable)");
+#endif
 
+#ifdef IPV6_MINHOPCOUNT
 		else if (af == AF_INET6 && setsockopt(s, IPPROTO_IPV6,
 		    IPV6_MINHOPCOUNT, &minttl, sizeof(minttl)))
 			err(1, "set IPv6 min hop count");
+#else
+		else if (af == AF_INET6)
+			errx(1, "can't set IPv6 min hop count (unavailable)");
+#endif
 	}
 }
 
@@ -1641,6 +2115,7 @@
 		{ "cs7",		IPTOS_DSCP_CS7 },
 		{ "ef",			IPTOS_DSCP_EF },
 		{ "inetcontrol",	IPTOS_PREC_INTERNETCONTROL },
+		{ "lowcost",		IPTOS_LOWCOST },
 		{ "lowdelay",		IPTOS_LOWDELAY },
 		{ "netcontrol",		IPTOS_PREC_NETCONTROL },
 		{ "reliability",	IPTOS_RELIABILITY },
@@ -1658,6 +2133,7 @@
 	return 0;
 }
 
+#ifdef HAVE_TLS
 int
 process_tls_opt(char *s, int *flags)
 {
@@ -1771,6 +2247,7 @@
 		break;
 	}
 }
+#endif
 
 void
 report_sock(const char *msg, const struct sockaddr *sa, socklen_t salen,
@@ -1794,9 +2271,11 @@
 	case 0:
 		break;
 	case EAI_SYSTEM:
-		err(1, "getnameinfo");
+		warn("getnameinfo");
+		return;
 	default:
-		errx(1, "getnameinfo: %s", gai_strerror(herr));
+		warnx("getnameinfo: %s", gai_strerror(herr));
+		return;
 	}
 
 	fprintf(stderr, "%s on %s %s\n", msg, host, port);
@@ -1805,21 +2284,21 @@
 void
 help(void)
 {
+#ifdef DEBIAN_VERSION
+	fprintf(stderr, "OpenBSD netcat (Debian patchlevel " DEBIAN_VERSION ")\n");
+#endif
 	usage(0);
 	fprintf(stderr, "\tCommand Summary:\n\
 	\t-4		Use IPv4\n\
 	\t-6		Use IPv6\n\
-	\t-C certfile	Public key file\n\
-	\t-c		Use TLS\n\
+	\t-b		Allow broadcast\n\
+	\t-C		Send CRLF as line-ending\n\
 	\t-D		Enable the debug socket option\n\
 	\t-d		Detach from stdin\n\
-	\t-e name\t	Required name in peer certificate\n\
 	\t-F		Pass socket fd\n\
-	\t-H hash\t	Hash string of peer certificate\n\
 	\t-h		This help text\n\
 	\t-I length	TCP receive buffer length\n\
 	\t-i interval	Delay interval for lines sent, ports scanned\n\
-	\t-K keyfile	Private key file\n\
 	\t-k		Keep inbound sockets open for multiple connects\n\
 	\t-l		Listen mode, for inbound connects\n\
 	\t-M ttl		Outgoing TTL / Hop Limit\n\
@@ -1827,14 +2306,13 @@
 	\t-N		Shutdown the network socket after EOF on stdin\n\
 	\t-n		Suppress name/port resolutions\n\
 	\t-O length	TCP send buffer length\n\
-	\t-o staplefile	Staple file\n\
 	\t-P proxyuser\tUsername for proxy authentication\n\
 	\t-p port\t	Specify local port for remote connects\n\
-	\t-R CAfile	CA bundle\n\
+	\t-q secs\t	quit after EOF on stdin and delay of secs\n\
 	\t-r		Randomize remote ports\n\
 	\t-S		Enable the TCP MD5 signature option\n\
 	\t-s sourceaddr	Local source address\n\
-	\t-T keyword	TOS value or TLS options\n\
+	\t-T keyword	TOS value\n\
 	\t-t		Answer TELNET negotiation\n\
 	\t-U		Use UNIX domain socket\n\
 	\t-u		UDP mode\n\
@@ -1844,26 +2322,30 @@
 	\t-w timeout	Timeout for connects and final net reads\n\
 	\t-X proto	Proxy protocol: \"4\", \"5\" (SOCKS) or \"connect\"\n\
 	\t-x addr[:port]\tSpecify proxy address and port\n\
-	\t-Z		Peer certificate file\n\
+	\t-Z		DCCP mode\n\
 	\t-z		Zero-I/O mode [used for scanning]\n\
 	Port numbers can be individual or ranges: lo-hi [inclusive]\n");
-	exit(1);
+	exit(0);
 }
 
 void
 usage(int ret)
 {
 	fprintf(stderr,
-	    "usage: nc [-46cDdFhklNnrStUuvz] [-C certfile] [-e name] "
-	    "[-H hash] [-I length]\n"
-	    "\t  [-i interval] [-K keyfile] [-M ttl] [-m minttl] [-O length]\n"
-	    "\t  [-o staplefile] [-P proxy_username] [-p source_port] "
-	    "[-R CAfile]\n"
-	    "\t  [-s sourceaddr] [-T keyword] [-V rtable] [-W recvlimit] "
-	    "[-w timeout]\n"
-	    "\t  [-X proxy_protocol] [-x proxy_address[:port]] "
-	    "[-Z peercertfile]\n"
+	    "usage: nc [-46CDdFhklNnrStUuvZz] [-I length] [-i interval] [-M ttl]\n"
+	    "\t  [-m minttl] [-O length] [-P proxy_username] [-p source_port]\n"
+	    "\t  [-q seconds] [-s sourceaddr] [-T keyword] [-V rtable] [-W recvlimit]\n"
+	    "\t  [-w timeout] [-X proxy_protocol] [-x proxy_address[:port]]\n"
 	    "\t  [destination] [port]\n");
 	if (ret)
 		exit(1);
 }
+
+/*
+ * quit()
+ * handler for a "-q" timeout (exit 0 instead of 1)
+ */
+static void quit()
+{
+	exit(0);
+}
